# есть вот такой стейт менеджер


```
export class Await {
	public readonly onReady: Promise<boolean>;
	private _readyResolve!: (value: boolean | PromiseLike<boolean>) => void;
	// private _readyReject!: (reason?: any) => void;
	constructor(){
		this.onReady = new Promise((resolve, reject)=>{
			this._readyResolve = resolve;
			// this._readyReject = reject;
		});
	}

	protected markAsReady(){
		this._readyResolve(true);
	}
}
```

```
import { PrimitiveRecord, Primitives, IUpdateStateEvent, IUpdateConditionEvent, CheckConditionHandler, PrimitiveSimple, checkValueAsPrimitiveSimple, checkValueAsStateNode } from "../common/commonTypes";
import { Await } from "../common/Await";

export class State extends Await {
	private data: PrimitiveRecord = {};
	private listeners: Map<string, Set<CheckConditionHandler>> = new Map();

	constructor() {
		super();
		// TODO в последствии стейт будет получать данные асинхроноо и нужно будет вынести setReady() после инициализации стейта
		this.markAsReady();
	}

	private cloneData(data: Primitives): Primitives {
		return Array.isArray(data) ? [...data] : data && typeof data === 'object' ? structuredClone(data) : data;
	}


	public set(path: string, value: PrimitiveSimple) {
		if (!checkValueAsPrimitiveSimple(value)) {
			throw new Error('Data is not of type PrimitiveSimple');
		}					
		// возможно PrimitiveSimple будет рассширен до плоских массивов и объектов
		const newValue = this.cloneData(value); 
		let oldValue: PrimitiveSimple;

		const keys = path.split('.');
		let node = this.data;

		keys.forEach((key: string, index: number) => {
			let nextNode: Primitives = node[key] as Primitives;
			if (index === keys.length - 1) {
				if (!checkValueAsPrimitiveSimple(nextNode)) throw new Error('Data is not of type PrimitiveSimple');
				oldValue = nextNode as PrimitiveSimple;
				node[key] = newValue;
				return;
			}

			if (!checkValueAsStateNode(nextNode)){
				throw new Error('Data is not of type Object');
			}
			node = node[key] = (nextNode ?? {}) as PrimitiveRecord;
		});

		if (newValue === oldValue) return;

		this.notify(path, { path, newData: value, oldData: oldValue });
	}

	// public getKeys(path: string): Array<string> {
	// 	let node: Primitives = this.getOriginal(path);
	// 	if (!node || typeof node !== 'object') return [];
	// 	return Object.keys(node as PrimitiveRecord)
	// }

	public get(path: string): Primitives {
		const node = this.getOriginal(path);
		return this.cloneData(node);
	}

	private getOriginal(path: string): Primitives {
		let node: Primitives = this.data;
		if (path === '') return node;
		path
			.split('.')
			.every((key) => {
				if (!node) return false;
				if (typeof node !== 'object') return false;
				node = (node as PrimitiveRecord)[key];
				return true;
			});
		return node;
	}

	public on(path: string, callback: CheckConditionHandler) {
		if (!this.listeners.has(path)) {
			this.listeners.set(path, new Set());
		}
		this.listeners.get(path)!.add(callback);
	}

	public off(path: string, callback: CheckConditionHandler): void {
		const listeners = this.listeners.get(path);
		listeners?.delete(callback);
		if (listeners?.size === 0) {
			this.listeners.delete(path);
		}
	}

	private async notify(path: string, data: IUpdateStateEvent) {
		const keys = path.split('.');
		if (keys.length === 0) return;

		let list: string[] = [];
		for (const key of keys) {
			list.push(key)
			const curentPath = list.join('.');
			const listeners = this.listeners.get(curentPath) ?? new Set();

			if (listeners.size === 0) continue;
			const isSubPath = path !== curentPath;
			const conditionEvent: IUpdateConditionEvent = {
				update: data,
				path: curentPath,
				newData: isSubPath ? this.get(curentPath) : this.cloneData(data.newData)
			};
			for (const listener of listeners) {
				await listener(conditionEvent);
			}
		}
	}
}

```

```
import { Await } from '../common/Await';
import { ChangeActiveHandler, CheckConditionHandler, Primitives, IUpdateConditionEvent, checkValueAsPrimitiveSimple, PrimitiveSimple } from '../common/commonTypes';
import { StateManager } from '../StateManager';

export interface IStateWatcherData {
	amount: number,
	watcher: StateWatcher
}

export class StateWatcher extends Await {
	public readonly state: StateManager;
	public readonly name: string;
	public readonly path: string;
	private _checkConditionHandler: CheckConditionHandler;
	private _countOfUses: number = 0;
	

	_isActive: boolean = false;
	_data: Primitives = null;
	_listeners: Set<ChangeActiveHandler> = new Set();

	constructor(state: StateManager, name: string, path: string, checkConditionHandler?: CheckConditionHandler) {
		super();
		this.state = state;
		this.name = name;
		this.path = path;
		this._checkConditionHandler = checkConditionHandler ?? this.checkConditionHandler;
		this.init();
	}

	private async init() {
		await this.state.onReady;
		this._data = this.state.getValue(this.path); // TODO со временем заменить на обращение через stateAPI
		this._isActive = await this._checkConditionHandler({
			update: {
				path: this.path,
				newData: this._data as PrimitiveSimple,
				oldData: this._data as PrimitiveSimple
			},
			path: this.path,
			newData: this._data,
			oldData: this._data
		});
		this.state.onStateUpdate(this.path, this.onUpdate); // TODO со временем заменить на обращение через stateAPI
		console.log('>>>', 'init condition', this.name, this._isActive)
		this.markAsReady();
	}

	on(listener: ChangeActiveHandler) {
		this._listeners.add(listener);
		this._countOfUses ++;
	}

	off(listener: ChangeActiveHandler) {
		this._listeners.delete(listener);
		this._countOfUses --;
	}

	get data(): Primitives {
		return this._data;
	}

	get isActive(): boolean {
		return this._isActive;
	}

	private checkConditionHandler = async (event: IUpdateConditionEvent): Promise<boolean> => {
		// асинхронный, потому что в последствии заменяется на пользовательский коллбэк 
		// который может выдавать результат асинхронно
		return event.path === event.path && !!event.update.newData === true;
	};


	private onUpdate = async (event: IUpdateConditionEvent) => {
		const data: IUpdateConditionEvent = {
			...event,
			oldData: this._data,
			newData: event.newData
		}
		this._data = event.newData;
		const isActive = this._isActive;
		this._isActive = await this._checkConditionHandler(data);

		if (this._isActive !== isActive) await this.notify();

		return isActive;
	}

	private async notify() {
		for (const listener of this._listeners) {
			await listener(this._isActive);
		}
	}

	public destroy() {
		this._listeners.clear();
		this.state.offStateUpdate(this.path, this.onUpdate);
	}
}

```

```
import { Await } from "./common/Await";
import { CheckConditionHandler, PrimitiveSimple, Primitives } from "./common/commonTypes";
import { State } from './state/State';
import { IStateWatcherData, StateWatcher } from "./trigger/StateWatcher";

export class StateManager  extends Await{
	public readonly name:string;
	private readonly state: State = new State();
	private readonly watchers: Map<string, IStateWatcherData> = new Map(); // TODO подумать как их использовать

	constructor(name: string){
		super()
		this.name = name;
		this.init();
	}
	private async init() {
		await this.state.onReady;
		this.markAsReady();
	}

	public setValue(path: string, value: PrimitiveSimple): void {
		this.state.set(path, value);
	}

	public getValue(path: string): Primitives {
		return this.state.get(path);
	}

	public onStateUpdate(path: string, callback: CheckConditionHandler): void {
		this.state.on(path, callback)
	}

	public offStateUpdate(path: string, callback: CheckConditionHandler): void {
		this.state.off(path, callback)
	}
}
```
вот пример его использования
```
import { ConditionFacade, IUpdateConditionEvent, StateManager, TriggerFacade } from "ohae_state";



(async function() {
	// тестирую использование StateManager


	const state = new StateManager('test');
	await state.onReady;
	const stateData = state.getValue('');
	console.log('!!!!!!!!!!!', stateData);
	
	
	state.setValue('novel.name', 'lower');
	state.setValue('novel.curentScene.name', '01_start');
	state.setValue('player.name', 'Alice');
	state.setValue('player.health', 100);
	state.setValue('player.isDeath', false);
	
	state.setValue('player.inventory.slot1', 'item1');
	state.setValue('player.inventory.slot2', null);
	
	
	// await StateFacade.addCondition('player', 'player', (event:UpdateConditionEvent)=>{
	// 	// console.log('>>>', 'update player condition', event);
	// 	return true;
	// });
	
	await ConditionFacade.add(state, 'slot1', 'player.inventory.slot1', (event:IUpdateConditionEvent)=>{
		console.log('>>>', 'update slot1 condition', event);
		return event.update.newData === 'item1';
	});
	
	await ConditionFacade.add(state, 'slot2', 'player.inventory.slot2', (event:IUpdateConditionEvent)=>{
		console.log('>>>', 'update slot2 condition', event);
		return event.update.newData === 'item2';
	});

	await ConditionFacade.add(state, 'inventory', 'player.inventory', (event:IUpdateConditionEvent)=>{
		console.log('>>>', 'update inventory condition', event);
		return true;
	});
	
	
	await ConditionFacade.add(state, 'isNotDeath', 'player.isDeath', (event:IUpdateConditionEvent)=>{
		console.log('>>>', 'update isNotDeath condition', event);
		return !event.update.newData;
	});
	
	await TriggerFacade.add('test', ['slot1', 'slot2', 'inventory', 'isNotDeath']);
	TriggerFacade.on('test', (isActive: boolean)=>{
		console.log('>>>', 'activate trigger', 'test', isActive)
	});
		
	setTimeout(()=>{
		state.setValue('player.inventory.slot2', 'item2');
	}, 5000);

	setTimeout(()=>{
		state.setValue('player.inventory.slot2', 'item3');
	}, 10000);
	
	
})()
```

и вот такая библиотека UI
```
import { EventHandlers, IOhaeViewOptions, LayoutDirection } from "./OhaeViewOptions";
import { OhaeBaseView } from "./widgets/OhaeBaseView";

export class OhaeUI {
    private static PREFIX: string = 'ohae-';
    private static viewTypes: Record<string, CustomElementConstructor> = {};
    private static viewList: Record<string, HTMLElement> = {};

    private parent: HTMLElement;
    public readonly view: Promise<HTMLElement | Text | (HTMLElement | Text)[] | null>;

    constructor(data: IOhaeViewOptions | string | (IOhaeViewOptions | string)[], parent: HTMLElement | string | null = null) {
        if (typeof parent === 'string') {
            this.parent = document.getElementById(parent) || document.body;
        } else {
            this.parent = parent || document.body;
        }
        this.view = OhaeUI.createView(data, this.parent);
    }

    static registerViewType(typeName: string, typeClass: CustomElementConstructor, options?: ElementDefinitionOptions) {
        OhaeUI.viewTypes[typeName] = typeClass;
        customElements.define(OhaeUI.getName(typeName), typeClass, options);
    }

    static getViewClassByType(typeName: string = 'layout'): CustomElementConstructor | undefined {
        return OhaeUI.viewTypes[typeName];
    }

    static getViewById(viewId: string): HTMLElement | undefined {
        return OhaeUI.viewList[viewId];
    }

    static isRegistered(typeName: string): boolean {
        return !!OhaeUI.viewTypes[typeName];
    }

    static getName(typeName: string): string {
        const list = typeName.split(/:/);
        if (list.length === 1) {
            return OhaeUI.viewTypes[typeName] ? OhaeUI.PREFIX + typeName : typeName;
        } else {
            return list[1];
        }
    }

    static getPrefixedId(id: string | number): string {
        return OhaeUI.PREFIX + id.toString();
    }

    static storeView(viewId: string, viewInstance: HTMLElement) {
        if (!viewId) return;
        OhaeUI.viewList[viewId] = viewInstance;
    }

    static async createView(data: IOhaeViewOptions | string | (IOhaeViewOptions | string)[], parent: HTMLElement): Promise<HTMLElement | (HTMLElement | Text)[] | Text | null> {
        if (!data) return null;

        if (typeof data === 'string') {
            return this.createHtmlBlock(data, parent);
        }

        if (Array.isArray(data)) {
            const fragments: (HTMLElement | Text)[] = [];
            for (const item of data) {
                const fragment = await OhaeUI.createView(item, parent);
                if (fragment) {
                    if (Array.isArray(fragment)) {
                        fragments.push(...fragment);
                    } else {
                        fragments.push(fragment);
                    }
                }

            }
            return fragments;
        }

        if (typeof data === 'object') {
            return await OhaeUI.createElement(data, parent);
        }
        return null;
    }

    private static createHtmlBlock(text: string, parent: HTMLElement): HTMLElement | Text | null {
        // const fragment = document.createTextNode(text);
        const fragment = document.createElement('span');
        parent.appendChild(fragment);
        fragment.innerHTML = text;
        return fragment;
        // parent.innerHTML += text;
        // return null;
    }

    public static async createElement(options: IOhaeViewOptions, parent?: HTMLElement): Promise<HTMLElement> {

        const viewType = options.view ?? 'layout';
        const viewName = OhaeUI.getName(viewType);
        const viewItem = document.createElement(viewName);
        OhaeUI.storeView(options.id, viewItem);

        if (viewItem instanceof OhaeBaseView) {
            viewItem.setAttribute('parentdirection', parent?.getAttribute('direction') ?? 'rows');
            await this.initOhaeHtmlElement(viewItem, options);
        } else {
            this.initStandartHtmlElement(viewItem, options);
        }
        parent?.appendChild(viewItem);

        this.applyListeners(viewItem, options.on);
        return viewItem;
    }

    private static async initOhaeHtmlElement(viewItem: OhaeBaseView, options: IOhaeViewOptions): Promise<void> {
        viewItem.setAttribute('direction', options.rows ? 'rows' : 'cols');
        const body = options.rows ?? options.cols ?? options.body;
        if (body) {
            await OhaeUI.createView(body, viewItem);
        }
        viewItem.init(options);
    }

    private static initStandartHtmlElement(viewItem: HTMLElement, options: IOhaeViewOptions) {
        Object.entries(options).forEach(([key, value]) => {
            if (key === 'id') {
                viewItem.setAttribute(key, this.getPrefixedId(value));
            } else if (typeof value != 'object' && value !== undefined) {
                (viewItem as OhaeBaseView).setAttribute(key, value.toString());
            }
        });
    }

    private static async applyListeners(element: HTMLElement, listeners?: EventHandlers): Promise<void> {
        if (!listeners) return;
        if (element instanceof OhaeBaseView) await element.onReady;
        Object.entries(listeners).forEach(([key, callback]) => {
            element.addEventListener(key, (event: Event) => {
                callback.call(element, event);
            });
        });
    }

}
```

```
export type AlignValues = 'flex-start' | 'flex-end' | 'center' | 'space-between' | 'space-around' | 'space-evenly' | 'start' | 'end' | 'none' ;
export type FlexAlignValues = 'stretch' | 'flex-start' | 'center' | 'flex-end' | 'baseline' | 'none';

type OhaeEventHandler = (this: HTMLElement, ev: Event) => void;

export interface  OhaeEvents {
    click?: OhaeEventHandler;
    change?: (this: HTMLElement, ev: Event) => void;
}

export type LayoutDirection = 'rows' | 'cols';

export interface IOhaeViewOptions {
    view?: string;
    backgroundColor?: string;
    block?: boolean | string;
    width?: string | number;
    minWidth?: string | number;
    maxWidth?: string | number;
    height?: string | number;
    minHeight?: string | number;
    maxHeight?: string | number;
    padding?: string | number;
    margin?: string | number;
    flex?: string | number;
    align?: AlignValues;
    valign?: FlexAlignValues;
    body?: (IOhaeViewOptions | string)[] | IOhaeViewOptions | string;
    rows?: (IOhaeViewOptions | string)[];
    cols?: (IOhaeViewOptions | string)[];
    on?: Record<string, (this: HTMLElement, ev: Event) => void>;

    [key: string]: any; // Для поддержки дополнительных атрибутов
}

export type EventHandlers = Record<string, EventHandler>;
export type EventHandler = (this: HTMLElement, ev: Event) => void;

```

с таким, базовым компонентом (от него или его потомков изначально наследуется все компоненты)
```
import { OhaeUI } from '../OhaeUI.ts';
import { AlignValues, EventHandler, EventHandlers, IOhaeViewOptions, LayoutDirection } from '../OhaeViewOptions.ts';
import { Color } from '../utils/Color.ts';

import { SizeNumber } from '../utils/SizeNumber.ts';

export class OhaeBaseView extends HTMLElement {
	public static readonly ATTRIBUTES: string[] = [
		'id',
		'align',
		'valign',
		'flex',
		'width',
		'height',
		'maxWidth',
		'maxHeight',
		'minWidth',
		'minHeight',
		'padding',
		'margin',
		'backgroundColor',
		'parentdirection',
	];
	protected static readonly STYLES: string = `
		<style>
			/* тут стили, я их пока из примера урал, чтобы ты на них не отвлекадся*/
		</style>
	`;
	protected static readonly FONT_AVESOME: string = `
		<style>
			/* тут подключение font awesome, тоже не отвлекайся на это*/			
		</style>	
	`;

	protected static readonly HTML: string = `
		<slot></slot>
	`;


	protected static readonly JUSTIFY_VALUES_MAP: Record<AlignValues, string> = {
			/* тут тоже убрал, не отвлекайся на это*/			
	}
	public readonly onReady: Promise<boolean>;
	private _readyResolve!: (value: boolean | PromiseLike<boolean>) => void;
	protected onInitDataReady!: Promise<boolean>;
	protected initData!: IOhaeViewOptions;
	private _initDataReadyResolve!: (value: boolean | PromiseLike<boolean>) => void;
	protected shadow!: ShadowRoot;


	constructor() {
		super();
		this.onReady = new Promise((resolve) => this._readyResolve = resolve);
		this.onInitDataReady = new Promise((resolve) => this._initDataReadyResolve = resolve);
		this.shadow = this.attachShadow({ mode: 'open' });
		this.createCallback();
	}

	static get observedAttributes(): string[] {
		return [...OhaeBaseView.ATTRIBUTES];
	}

	protected async connectedCallback() {
		// await this.createCallback();
		this.markAsReady();
	}

	protected async createCallback() {
		await this.onInitDataReady;
		await this.render();
		this.applyAttributes(OhaeBaseView.observedAttributes);
	}

	protected markAsReady() {
		this._readyResolve(true);
	}

	protected markAsInitDataReady() {
		this._initDataReadyResolve(true);
	}

	public init(options: IOhaeViewOptions) {
		Object.entries(options ?? {}).forEach(([key, value]) => {
			if (key === 'id') {
				this.setAttribute(key, OhaeUI.getPrefixedId(value));
			} else if (typeof value != 'object' && value !== undefined) {
				if (value !== null) this.setAttribute(key, value.toString());
			}
		});
		this.initData = options;
		this._initDataReadyResolve(true);
	}

	protected disconnectedCallback() {
	}

	protected attributeChangedCallback(name: string, oldValue: string, newValue: string) {
		if (oldValue !== newValue) {
			this.applyAttribute(name, newValue);
		}
	}

	protected async render() {
		const staticThis = (this.constructor as typeof OhaeBaseView);
		this.shadowRoot!.innerHTML = staticThis.STYLES + staticThis.HTML;
	}

	public override addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void {
		super.addEventListener(type, listener, options);
	}

	protected applyAttributes(attributes: string[]): void {
		attributes.forEach(name => {
			const value = this.getAttribute(name);
			if (value !== null) this.applyAttribute(name, value);
		});
	}

	protected applyAttribute(name: string, value: string): void {
		if (name in this) {
			(this as any)[name] = value;
		}
	}

	protected waitForShadowRoot(hostElement: HTMLElement = this): Promise<ShadowRoot> {
		return new Promise((resolve) => {
			if (hostElement.shadowRoot) {
				return resolve(hostElement.shadowRoot);
			}

			const observer = new MutationObserver((_, obs) => {
				if (hostElement.shadowRoot) {
					obs.disconnect();
					resolve(hostElement.shadowRoot);
				}
			});

			observer.observe(hostElement, {
				childList: false,
				subtree: false,
				attributes: false,
				// Наблюдаем за изменениями, связанными с ShadowRoot
				characterData: false,
			});
		});
	};

	get flex(): number | null {
		const value = this.getAttribute('flex');
		if (!value) return null
		return parseFloat(value);
	}
	set flex(value: string | number | null) {
		if (value === null) return;

		if (value === 'none') {
			this.style.flexGrow = 'none';
			this.setAttribute('flex', 'none');
		} else if (typeof value === 'number') {
			this.style.flexGrow = value.toString();
			this.setAttribute('flex', value.toString());
		} else {
			this.style.flexGrow = value;
		}
	}

	get backgroundColor(): Color | null {
		const backgroundColor = this.getAttribute('backgroundColor');
		if (!backgroundColor) return null;
		return new Color(backgroundColor);
	}
	set backgroundColor(value: string | Color | null) {
		if (!value) return;

		const color = typeof value === 'string' ? new Color(value) : value;
		this.setAttribute('backgroundColor', color.hex);

		this.style.setProperty("--host-bg", color.hex);
		this.style.setProperty("--host-color", color.contrast(0.5).mono().hex);
		this.style.setProperty("--host-hr-color", color.contrast(0.2).mono().hex);

		this.style.setProperty("--host-hover-bg", color.brightness(1.1).hex);
		this.style.setProperty("--host-active-bg", color.brightness(1.2).hex);
		this.style.setProperty("--host-border", color.brightness(0.8).hex);
		this.style.setProperty("--host-head-bg", color.brightness(0.5).mono().hex);
		this.style.setProperty("--host-head-color", color.contrast(0.5).mono().hex);
	}

	get align(): string | null {
		return this.getAttribute('valign');
	}
	set align(value: string | null) {
		if (value === null) return;
		this.setAttribute('align', value);
		this.style.textAlign = OhaeBaseView.JUSTIFY_VALUES_MAP[value as AlignValues];
		this.style.justifyContent = value;
	}

	get valign(): string | null {
		return this.getAttribute('align');
	}
	set valign(value: string | null) {
		if (value === null) return;
		this.style.alignItems = value;
	}

	get margin(): string | null {
		return this.getAttribute('margin');
	}
	set margin(value: string | number | null) {
		if (value === null) return;
		const parsedValue = this.parseSizeValue(value);
		this.setAttribute('margin', parsedValue);
		this.style.margin = parsedValue;
	}

	get padding(): string | null {
		return this.getAttribute('padding');
	}
	set padding(value: string | number | null) {
		if (value === null) return;
		const parsedValue = this.parseSizeValue(value);
		this.setAttribute('padding', parsedValue);
		this.style.padding = parsedValue;
	}

	get height(): string | null {
		return this.getAttribute('height');
	}
	set height(value: string | number | null) {
		if (value === null) return;
		const parsedValue = this.parseSizeValue(value);
		this.setAttribute('height', parsedValue);
		this.style.height = parsedValue;
	}

	get minHeight(): string | null {
		return this.getAttribute('minHeight');
	}

	set minHeight(value: string | number | null) {
		if (value === null) return;
		const parsedValue = this.parseSizeValue(value);
		this.setAttribute('minHeight', parsedValue);
		this.style.minHeight = parsedValue;
	}

	get maxHeight(): string | null {
		return this.getAttribute('maxHeight');
	}
	set maxHeight(value: string | number | null) {
		if (value === null) return;
		const parsedValue = this.parseSizeValue(value);
		this.setAttribute('maxHeight', parsedValue);
		this.style.maxHeight = parsedValue;
	}

	get width(): string | null {
		return this.getAttribute('width');
	}
	set width(value: string | number | null) {
		if (value === null) return;
		const parsedValue = this.parseSizeValue(value);
		this.setAttribute('width', parsedValue);
		this.style.width = parsedValue;
	}

	get minWidth(): string | null {
		return this.getAttribute('minWidth');
	}
	set minWidth(value: string | number | null) {
		if (value === null) return;
		const parsedValue = this.parseSizeValue(value);
		this.setAttribute('minWidth', parsedValue);
		this.style.minWidth = parsedValue;
	}

	get maxWidth(): string | null {
		return this.getAttribute('maxWidth');
	}

	set maxWidth(value: string | number | null) {
		if (value === null) return;
		const parsedValue = this.parseSizeValue(value);
		this.setAttribute('maxWidth', parsedValue);
		this.style.maxWidth = parsedValue;
	}

	protected parseSizeValue(value: string | number): string {
		value = value.toString()
		const parsedNumber = parseFloat(value);
		if (typeof parsedNumber === 'number') {
			const number = new SizeNumber(value);
			return number.toString();
		} else {
			return value;
		}
	}

	protected parseNumberValue(value: string | number): string {
		const number = new SizeNumber(value);
		return number.toNumber().toString();
	}

	protected setBooleanAttribute(attributeName: string, value: boolean | string | null, target?: HTMLElement): boolean {
		value = value === true || value === 'true';
		target = target ?? this;
		if (value) {
			target.setAttribute(attributeName, value.toString());
		} else {
			target.removeAttribute(attributeName);
		}
		return value;
	}
}

OhaeUI.registerViewType('base', OhaeBaseView);
```

далее пример нескольких компонентов
```
import { OhaeUI } from '../../OhaeUI';
import { OhaeBaseView } from '../OhaeBaseView';

export class OhaeLayoutView extends OhaeBaseView {
    public static readonly ATTRIBUTES: string[] = [
        'collapsed',
        'direction',
        'overflow',
        'overflowX',
        'overflowY',
    ];
	protected static readonly STYLES: string = `
        <style>
            :host {
                border-radius: 3px;
                display: flex;
                overflow: auto;
                box-sizing: border-box;
                padding: 0px;
                margin: 0px;
                flex-grow: 1;
            }
            /* :host(:not([backgroundColor])) { */
            :host([backgroundColor]) {
                background-color:  var(--host-bg, #333);
                box-shadow: 2px 2px 2px rgba(0, 0, 0, .1);
                color: var(--host-color, #ddd);
            }
            :host([direction="rows"]) {
                flex-direction: column;
            }
            :host([direction="cols"]) {
                flex-direction: row;
            }
            :host([collapsed]) {
                display: none;
            }
            ::slotted(*) {
                flex: 1;  /* Все элементы слота будут равномерно растянуты */
                min-width: 0; /* Позволяет элементам сужаться */
            }
        </style>
	`;

    private resizeObserver: ResizeObserver;

    constructor() {
        super();
        this.resizeObserver = new ResizeObserver(() => this.handleResize());
    }

    static get observedAttributes() {
        return [...super.observedAttributes, ...this.ATTRIBUTES];
    }

    protected override async createCallback() {
        await super.createCallback();
        this.applyAttributes(OhaeLayoutView.ATTRIBUTES);
        this.resizeObserver.observe(this);
    }

    protected override disconnectedCallback() {
        super.disconnectedCallback();
        this.resizeObserver.disconnect();
    }

    private handleResize() {
        // Логика для обработки изменения размеров
    }

    public show() {
        this.collapsed = false;
    }

    public hide() {
        this.collapsed = true;
    }

    get overflow(): string | null {
        return this.getAttribute('overflow');
    }
    set overflow(value: string | null) {
        if (value === null) return;
        this.setAttribute('overflow', value);
        this.style.overflow = value;
    }

    get overflowX(): string | null {
        return this.getAttribute('overflowX');
    }
    set overflowX(value: string | null) {
        if (value === null) return;
        this.setAttribute('overflowX', value);
        this.style.overflowX = value;
    }

    get overflowY(): string | null {
        return this.getAttribute('overflowY');
    }
    set overflowY(value: string | null) {
        if (value === null) return;
        this.setAttribute('overflowY', value);
        this.style.overflowY = value;
    }

    get collapsed(): boolean {
		return this.getAttribute('collapsed') === 'true';
	};
	set collapsed(value: boolean | string | null) {
        this.setBooleanAttribute('collapsed', value);
    }
}

OhaeUI.registerViewType('layout', OhaeLayoutView);


declare module "../../OhaeViewOptions" {
    interface IOhaeViewOptions {
        collapsed?: boolean | string;
        direction?: LayoutDirection;
        overflow?: string;
        overflowX?: string;
        overflowY?: string;
    }
}
```

```
import { OhaeUI } from "../../OhaeUI";
import { OhaeLayoutView } from "../layout-view/OhaeLayoutView";
import { OhaeAccordionItemView } from "./OhaeAccordionItemView";

export class OhaeAccordionView extends OhaeLayoutView {
    public static readonly ATTRIBUTES: string[] = [
        'multiple',
        'enableShift',
        'enableDrag',
    ];

    protected static readonly STYLES: string = `
    <style>
	/* тут стили, я их пока из примера урал, чтобы ты на них не отвлекадся*/
    </style>
    `;
    public draggedSection: OhaeAccordionItemView | null = null;

    protected override async createCallback() {
        await super.createCallback();
        this.applyAttributes(OhaeAccordionView.ATTRIBUTES);
        this.addEventListener('section-toggle', this.handleSectionToggle as EventListener);
        this.addEventListener('dragover', this.handleDragOver as EventListener);
        this.addEventListener('drop', this.handleDrop as EventListener);
    }

    static get observedAttributes() {
        return [...super.observedAttributes, ...this.ATTRIBUTES];
    }

    private handleDragOver(event: DragEvent) {
        event.preventDefault();
        const target = event.target as HTMLElement;
        const section = target.closest('ohae-accordion-item') as OhaeAccordionItemView | null;
        if (section && this.draggedSection && section !== this.draggedSection) {
            const rect = section.getBoundingClientRect();
            const isAfter = event.clientY > rect.top + rect.height / 2;
            console.log(1);
            if (isAfter) {
                if(section.nextElementSibling === this.draggedSection) return
                section.after(this.draggedSection);
            } else {
                if(section.previousElementSibling === this.draggedSection) return
                section.before(this.draggedSection);
            }
        }
    }
    
    private handleDrop(event: DragEvent) {
        event.preventDefault();
        this.draggedSection = null;
    }

    private handleSectionToggle(event: Event) {
        const customEvent = event as CustomEvent;
        const targetSection = customEvent.detail.section as OhaeAccordionItemView;
        this.tryToggledSections(targetSection);
        this.tryShiftToggledSection(targetSection);
    }

    private tryToggledSections(ignoreSection: OhaeAccordionItemView) {
        const sections = this.querySelectorAll('ohae-accordion-item') as NodeListOf<OhaeAccordionItemView>;
        if (!this.multiple) {
            sections.forEach(section => {
                if (section !== ignoreSection) {
                    section.collapsed = true; // Сворачиваем все секции, кроме текущей
                }
            });
        }
    }

    private tryShiftToggledSection(targetSection: OhaeAccordionItemView) {
        if (this.enableShift) {
            const sections = this.querySelectorAll('ohae-accordion-item') as NodeListOf<OhaeAccordionItemView>;
            // const isColapsed = targetSection.collapsed;
            Array.from(sections).some(section => {
                if (section !== targetSection && section.collapsed) {
                    // if (isColapsed) {
                    //     this.insertBefore(targetSection, section);
                    // } else {
                        this.insertBefore(targetSection, section);
                    // }
                    return true;
                }
            });
            this.scrollTop = 0;
        }
    }


    get multiple(): boolean {
        return this.getAttribute('multiple') === 'true';
    };
    set multiple(value: boolean | string | null) {
        this.setBooleanAttribute('multiple', value);
    }

    get enableShift(): boolean {
        return this.getAttribute('enableShift') === 'true';
    };
    set enableShift(value: boolean | string | null) {
        this.setBooleanAttribute('enableShift', value);
    }
    
    get enableDrag(): boolean {
        return this.getAttribute('enableDrag') === 'true';
    };
    set enableDrag(value: boolean | string | null) {
        this.setBooleanAttribute('enableDrag', value);
    }
}

OhaeUI.registerViewType('accordion', OhaeAccordionView);

declare module "../../OhaeViewOptions" {
    interface IOhaeViewOptions {
        enableShift?: string | boolean;
        multiple?: string | boolean | number;
    }
}
```

```
import { OhaeUI } from "../../OhaeUI";
import { OhaeLayoutView } from "../layout-view/OhaeLayoutView";
import { OhaeAccordionView } from "./OhaeAccordionView";

export class OhaeAccordionItemView extends OhaeLayoutView {
    public static readonly ATTRIBUTES: string[] = [
        'collapsed',
        'header',
        'openIcon',
        'closeIcon',
    ];

    protected static readonly STYLES: string = `
    <style>
	/* тут стили, я их пока из примера урал, чтобы ты на них не отвлекадся*/
    </style>
    ` + this.FONT_AVESOME;
    protected static readonly ICON_OPEN: string = 'fa-angle-right'; // fa-chevron-right
    protected static readonly ICON_CLOSE: string = 'fa-angle-down'; // fa-chevron-down
    protected static readonly ICON_MOVE: string = 'fa-ellipsis-h'; // fa-ellipsis-h

    protected static readonly HTML: string = `
        <div class="header">
            <span id='icon-wrapper'><span id='icon' class='icon fa ${this.ICON_CLOSE}'></span></span>
            <div class="header-body"></div>
            <span id='icon-wrapper'><span id='icon-move' class='icon-move fa ${this.ICON_MOVE}'></span></span>
        </div>
        <div class="body">
            <slot></slot>
        </div>
    `;
    private iconElement?: HTMLElement;
    private moveIconElement?: HTMLElement;

    protected override async createCallback() {
        await super.createCallback();
        this.iconElement = this.shadowRoot?.querySelector('.icon') as HTMLElement;
        this.applyAttributes(OhaeAccordionItemView.ATTRIBUTES);
        this.backgroundColor = this.backgroundColor ?? "#444";

        const header = this.shadowRoot?.querySelector('.header') as HTMLElement;
        if (header) {
            header.addEventListener('click', this.toggleCollapse.bind(this) as EventListener);
        }

        this.moveIconElement = this.shadowRoot?.querySelector('#icon-move') as HTMLElement;
        
        this.updateIcon();
        this.updateEnableDragging();
    }

    static get observedAttributes() {
        return [...super.observedAttributes, ...this.ATTRIBUTES];
    }

    private updateEnableDragging(): void {
        this.moveIconElement?.removeEventListener('mousedown', this.handleDragIconStart as EventListener);
        this.moveIconElement?.removeEventListener('mouseup', this.handleDragIconEnd as EventListener);
        const enableDragging = true; //this.enableDragging;
        if(enableDragging){
            this.moveIconElement?.addEventListener('mousedown', this.handleDragIconStart as EventListener);
            this.moveIconElement?.addEventListener('mouseup', this.handleDragIconEnd as EventListener);
        }
    }

    private handleDragIconStart = (event: Event)=>{
        this.draggable = true;
        this.addEventListener('dragstart', this.handleDragStart as EventListener);
        this.addEventListener('dragend', this.handleDragEnd as EventListener);
    }

    private handleDragIconEnd = (event: Event)=>{
        this.draggable = false;
        this.removeEventListener('dragstart', this.handleDragStart as EventListener);
        this.removeEventListener('dragend', this.handleDragEnd as EventListener);
    }

    private handleDragStart(event: DragEvent) {
        event.stopPropagation();
        
        this.style.opacity = '0.4';

        // const accordion = this.closest('ohae-accordion-view') as OhaeAccordionView | null;
        const accordion = this.parentElement as OhaeAccordionView;
        if (accordion) {
            accordion.draggedSection = this;
        }

        // Создаем прозрачную картинку 1x1
        const emptyImage = new Image();
        emptyImage.src = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxIiBoZWlnaHQ9IjEiPjwvc3ZnPg==';
        event.dataTransfer?.setDragImage(emptyImage, 0, 0);
    }
    
    private handleDragEnd() {
        this.draggable = false;
        this.style.opacity = '';
    }

    private toggleCollapse() {
        this.collapsed = !this.collapsed;

        // Генерация события section-toggle
        const event = new CustomEvent('section-toggle', {
            bubbles: true, // Событие всплывает до родительских элементов
            composed: true, // Событие пересекает границы Shadow DOM
            detail: { section: this, collapsed: this.collapsed },
        });
        this.dispatchEvent(event);
    }

    private updateIcon() {
        if (!this.iconElement) return;
        this.iconElement.className = `icon fa ${this.collapsed ? this.openIcon : this.closeIcon}`;
        //this.iconElement.style.color = (this.collapsed ? this.color?.rgba : this.color?.brightness(0.7).rgba) ?? "#fff";
    }

    get collapsed(): boolean {
        return this.getAttribute('collapsed') === 'true';
    };
    set collapsed(value: boolean | string | null) {
        value = this.setBooleanAttribute('collapsed', value);
        const body = this.shadowRoot?.querySelector('.body') as HTMLElement;
        if (value) {
            body?.classList.add('collapse');
        } else {
            body?.classList.remove('collapse');
        }
        this.updateIcon();
    }

    get header(): string {
        const headerBody = this.shadowRoot?.querySelector('.header-body') as HTMLElement;
        return headerBody?.innerText ?? '';
    }
    set header(value: string) {
        const headerBody = this.shadowRoot?.querySelector('.header-body') as HTMLElement;
        if (headerBody) {
            headerBody.innerText = value ?? '';
        }
    }

    get openIcon(): string {
        return this.getAttribute('openIcon') || OhaeAccordionItemView.ICON_OPEN;
    }
    set openIcon(value: string) {
        this.setAttribute('openIcon', value);
        this.updateIcon();
    }

    get closeIcon(): string {
        return this.getAttribute('closeIcon') || OhaeAccordionItemView.ICON_CLOSE;
    }
    set closeIcon(value: string) {
        this.setAttribute('closeIcon', value);
        this.updateIcon();
    }

}

OhaeUI.registerViewType('accordion-item', OhaeAccordionItemView);

declare module "../../OhaeViewOptions" {
    interface IOhaeViewOptions {
        collapsed?: string | boolean;
        header?: string;
        openIcon?: string;
        closeIcon?: string;
    }
}

```

```
import { OhaeUI } from "../../OhaeUI";
import { OhaeBaseView } from "../OhaeBaseView";

export class OhaeBaseInputView extends OhaeBaseView {
	public static readonly ATTRIBUTES: string[] = [
		'value',		
		'name',
		'separator',
		'label',
		'inputWidth',
		'disabled',
		'readonly',
		'required',
		'reverse',
	];

	protected static readonly STYLES: string = `
	<style>
		/* тут стили, я их пока из примера урал, чтобы ты на них не отвлекадся*/
	</style>
	`;

	protected static readonly HTML: string = `
		<div class="input-wrapper">
			<div class="input-box">
				<label class="input-container">
					<input class="input" />
					<span class="switch"></span>
				</label>				
			</div>
			<div class="input-separator"></div>
			<label class="input-label"></label>
		</div>
	`;
	protected oldValue: any;


	protected override async createCallback() {
		await super.createCallback();
		this.applyAttributes(OhaeBaseInputView.ATTRIBUTES);
		this.oldValue = this.value;
	}

	static get observedAttributes() {
		return [...super.observedAttributes, ...this.ATTRIBUTES];
	}

	protected get inputWrapperView(): HTMLDivElement {
		return this.shadowRoot?.querySelector('.input-wrapper') as HTMLDivElement;
	}

	protected get inputBoxView(): HTMLDivElement {
		return this.shadowRoot?.querySelector('.input-box') as HTMLDivElement;
	}

	protected get inputView(): HTMLInputElement {
		return this.shadowRoot?.querySelector('input') as HTMLInputElement;
	}

	protected get separatorView(): HTMLDivElement {
		return this.shadowRoot?.querySelector('.input-separator') as HTMLDivElement;
	}

	protected get labelView(): HTMLLabelElement {
		return this.shadowRoot?.querySelector('.input-label') as HTMLLabelElement;
	}


	private static readonly inputListeners: string[] = ['change'];
	public override addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void{
		if(OhaeBaseInputView.inputListeners.includes(type)){
			this.inputView.addEventListener(type, (e)=>{
				e.stopPropagation();
				this.modifyInputEvent(e as InputEvent);
			});
		}
		super.addEventListener(type, listener, options);
	}
	
	private modifyInputEvent(originalEvent: InputEvent): void {
		if(this.oldValue === this.value) return;
		const detail = {
			originalEvent,
			newValue: this.value,
			oldValue: this.oldValue,
		};
		const event = new CustomEvent(originalEvent.type, {
			bubbles: true, // Событие всплывает до родительских элементов
			composed: true, // Событие пересекает границы Shadow DOM
			detail,
		});

		this.dispatchEvent(event);
		if(originalEvent.type === 'change')	this.oldValue = this.value;
	}


	get value(): string | number | boolean {
		return this.inputView?.value;
	}
	set value(value: string | number | boolean | null) {
		if (value === null) return;
		this.setAttribute('value', value.toString());
		const view = this.inputView;
		if (view) view.value = value.toString();
	}

	get name(): string | null {
		return this.getAttribute('name');
	}
	set name(value: string | null) {
		if (value === null) {
			this.removeAttribute('name');
			this.inputView?.removeAttribute('name');
		} else {
			this.setAttribute('name', value);
			this.inputView?.setAttribute('name', value);
		}
	}

	get separator(): string {
		return this.separatorView?.innerText || '💥'; //'●';
	}
	set separator(value: string | null) {
		if (value === null) return;
		this.setAttribute('separator', value);

		const view = this.separatorView;
		if (view) view.innerText = value;
	}

	get label(): string | null {
		return this.getAttribute('label');
	}
	set label(value: string | null) {
		if (value === null) return;
		this.setAttribute('label', value);

		const view = this.labelView;
		if (view) view.innerText = value;
	}

	get inputWidth(): string | null {
		return this.getAttribute('inputWidth');
	}
	set inputWidth(value: string | number | null) {
		if (value === null) return;
		const parsedValue = this.parseSizeValue(value);
		this.setAttribute('inputWidth', parsedValue);
		this.inputBoxView?.style.setProperty('--input-width', parsedValue);
	}

	get disabled(): boolean {
		return this.getAttribute('disabled') === 'true';
	};
	set disabled(value: boolean | string | null) {
		this.setBooleanAttribute('disabled', value);
		this.setBooleanAttribute('disabled', value, this.inputView);
	}

	get readonly(): boolean {
		return this.getAttribute('readonly') === 'true';
	};
	set readonly(value: boolean | string | null) {
		value = this.setBooleanAttribute('readonly', value);
		const view = this.inputView;
		if ((view as any)?.readOnly) (view as any).readOnly = value;
	}

	get required(): boolean {
		return this.getAttribute('required') === 'true';
	};
	set required(value: boolean | string | null) {
		value = this.setBooleanAttribute('required', value);
		const view = this.separatorView;
		if (!view) return;
		view.innerText = value ? this.separator : '';
	}

	get reverse(): boolean {
		return this.getAttribute('reverse') === 'true';
	};
	set reverse(value: boolean | string | null) {
		value = this.setBooleanAttribute('reverse', value);
		if (!this.inputBoxView || !this.labelView || !this.inputWrapperView) return;
	}
}

OhaeUI.registerViewType('base-input', OhaeBaseInputView);


declare module "../../OhaeViewOptions" {
    interface IOhaeViewOptions {
		name?: string;
		separator?: string;
		label?: string;
		inputWidth?: string | number;
		disabled?: string | boolean;
		readonly?: string | boolean;
		required?: string | boolean;
		reverse?: string | boolean;
    }
}
```

вот пример использования этой UI библиотеки
```
import "./core/widgets/OhaeBaseView";
import "./core/widgets/OhaeFieldsetView";
import "./core/widgets/layout-view/OhaeLayoutView";
import "./core/widgets/layout-view/OhaeResizerView";
import "./core/widgets/layout-view/OhaeSeparatorView";
import "./core/widgets/input_view/OhaeButtonView";
import "./core/widgets/input_view/OhaeFormView";
import "./core/widgets/input_view/OhaeInputView";
import "./core/widgets/input_view/OhaeSelectView";
import "./core/widgets/input_view/OhaeTextareaView";
import "./core/widgets/input_view/OhaeIconCheckboxView";
import "./core/widgets/input_view/OhaeIconSelectView";
import "./core/widgets/accordion_view/OhaeAccordionView";
import "./core/widgets/accordion_view/OhaeAccordionItemView";
import "./core/widgets/icons_view/OhaeIconOfTypeView";
import "./core/widgets/tabs_view/OhaeTabsView";
import "./core/widgets/tabs_view/OhaeTabItemButton";
import "./core/widgets/tabs_view/OhaeTabItemView";
import "./core/widgets/data_table_view/OhaeDataTableView";
import "./external_widgets/OhaeAceEditor";
import "./external_widgets/BlenderNumberInput";

import { IOhaeViewOptions } from "./core/OhaeViewOptions";
import { OhaeUI } from './core/OhaeUI';
import { OhaeLayoutView } from "./core/widgets/layout-view/OhaeLayoutView";
import { workSpaceViewData } from "./custom_views_data/workspace_view/workSpaceViewData";
import { ConditionFacade, IUpdateConditionEvent, StateManager, TriggerFacade } from "ohae_state";

// Пример JSON-данных для инициализации
const dataInputView: IOhaeViewOptions = {
	view: 'layout',
	minWidth: '100%',
	overflow: 'hidden',
	// overflowX: 'scroll',
	// overflowY: 'scroll',
	rows: [
		{ view: 'layout', backgroundColor: '#111', minHeight: 26, maxHeight: 26, 
			body: {
				view: 'layout',
				padding: 0,
				// backgroundColor: '#411',
				cols: [
					{
						view: 'layout',
						maxHeight: 24,
						maxWidth: 48,
						minWidth: 48,
						overflow: 'hidden',
						margin: 6,
						flex: 0,
						valign: 'center',
						body: {
							view: 'img',
							height: '16px',
							src: './assets/logo_64.png',
							on: {
								click: function (){
									console.log('logo')
								}
							}
						},
				
					},
					{
						flex: 1
					},
				],
			}
		},
		{ view: 'layout', minHeight: 1, maxHeight: 1 },
		workSpaceViewData, 
		{ view: 'layout', minHeight: 1, maxHeight: 1 },
		{ view: 'layout', backgroundColor: '#111', minHeight: 22, maxHeight: 22 },
	],
};


const ui = new OhaeUI(dataInputView, document.body);

const element = OhaeUI.getViewById('main') as OhaeLayoutView;

// в переменной workSpaceViewData остальная часть интерфейса, (на самом деле там такде идут отсылки на другие файлы с данными о разных частях интерфейса)


```


давай подумаем как будет правильнее встроить стейт в библиотеку UI.
Оцени возможные стратегии использования и архитектуры, предложи варианты, опиши их, укажи для них плюсы и минусы, оцени какой из предложенных тобой вариантов лучше подойдет для создания десктопного приложения - графического редакотора для создания игровых ассетов (по типу adobe animate)

<hr>

Давайте рассмотрим возможные стратегии интеграции стейт-менеджера в UI-библиотеку для графического редактора:

### 1. Прямая интеграция через наследование компонентов
**Стратегия**: Создать базовый `StateAwareComponent`, от которого наследуются все UI-компоненты
**Плюсы**:
- Централизованное управление подписками
- Единый интерфейс для работы с состоянием
- Автоматическая отписка при уничтожении компонента

**Минусы**:
- Жесткая привязка к архитектуре компонентов
- Сложность миграции существующих компонентов
- Потенциальные конфликты с существующей иерархией наследования

### 2. Паттерн Observer с декораторами
**Стратегия**: Использовать декораторы для связывания свойств компонента с путями в состоянии
```typescript
@BindState('tool.current')
class ToolButton extends OhaeBaseView {
  // ...
}
```
**Плюсы**:
- Гибкая настройка связей
- Минимальное вмешательство в существующий код
- Возможность тонкой настройки подписок

**Минусы**:
- Сложность реализации для разных типов данных
- Ограниченная поддержка в некоторых браузерах
- Возможные проблемы с производительностью

### 3. Контекстное внедрение через Provider
**Стратегия**: Создать StateProvider на верхнем уровне приложения
```typescript
new StateProvider({
  state: new StateManager('app'),
  children: [/* компоненты */]
});
```
**Плюсы**:
- Изоляция состояния
- Легкий доступ из любых компонентов
- Возможность использования нескольких состояний

**Минусы**:
- Усложнение архитектуры
- Необходимость передачи контекста через уровни
- Потенциальные проблемы с обновлениями

### 4. Реактивные прокси-объекты
**Стратегия**: Создать реактивную обертку над состоянием
```typescript
const reactiveState = createReactiveProxy(stateManager);
reactiveState.player.health = 100; // Автоматически триггерит обновления
```
**Плюсы**:
- Интуитивный синтаксис
- Автоматическая синхронизация
- Поддержка сложных структур данных

**Минусы**:
- Высокая сложность реализации
- Потенциальные проблемы с производительностью
- Ограничения для больших наборов данных

### 5. Комбинированный подход (Рекомендуемый)
Для графического редактора типа Adobe Animate лучше всего подойдет комбинация нескольких стратегий:

**Архитектура**:
```
[State Manager] ↔ [State Connector] ↔ [UI Components]
                ↗           ↖
        (декораторы)    (контекст)
```

**Реализация**:
1. **StateProvider** на корневом уровне приложения
2. **Декораторы** для простых компонентов (кнопки, инпуты)
3. **Ручные подписки** для сложных компонентов (холст, временная шкала)
4. **Оптимизированные селекторы** для работы с большими данными

**Преимущества для графического редактора**:
- 🎨 **Производительность**: Точечные обновления только затронутых компонентов
- 🔄 **Отмена/Повтор**: Легко реализуется через историю изменений состояния
- 🧩 **Модульность**: Возможность изолировать состояние разных панелей
- 🔍 **Отладка**: Централизованный контроль за изменениями состояния
- 📊 **Сложные зависимости**: Легко реализовать связи между разными частями интерфейса

**Пример интеграции**:
```typescript
class CanvasEditor extends OhaeBaseView {
  private _unsubscribe: () => void;

  async connectedCallback() {
    const state = await StateProvider.getState(this);
    this._unsubscribe = state.watch('canvas.layers', this.updateLayers);
  }

  disconnectedCallback() {
    this._unsubscribe();
  }

  @BindState('canvas.activeTool')
  updateActiveTool(tool: string) {
    // Обновить UI выбранного инструмента
  }
}
```

**Ключевые оптимизации**:
1. Batch-обновления для группировки изменений
2. Приоритетное обновление видимых элементов
3. Двойная буферизация для графических элементов
4. Ленивая загрузка сложных состояний
5. Мемоизация селекторов

Для редактора ассетов этот подход обеспечит:
- Мгновенную реакцию на действия пользователя
- Легкую интеграцию новых инструментов
- Стабильную работу с большими проектами
- Простую отладку сложных сценариев
- Возможность расширения функционала без переписывания архитектуры


<hr>

# отлично, давай реализуем - 5. Комбинированный подход (Рекомендуемый)

давай напишем необходимые изменения кода и доп модули для:
- State Manager
- State Connector
- приведенных выше UI Components 
- декораторы
- контекст

а так же напишем примеры использования:
- подписки отписки компонент к данным в стейте
- реактивного обновления состояния компонент в зависимости от изменений в стейте
- сохранение атрибутов UI компонент в стейте, и востанавление их по внешней команде/сигналу


Реализуем поэтапно:

### 1. State Connector Module (core/state/StateConnector.ts)
```typescript
import { StateManager } from "./StateManager";
import { Await } from "./Await";

type Unsubscribe = () => void;
type StateUpdateHandler<T = any> = (value: T) => void;

export class StateConnector extends Await {
    private static subscriptions = new WeakMap<HTMLElement, Unsubscribe[]>();
    private static statePromises = new WeakMap<HTMLElement, Promise<StateManager>>();

    static connect(element: HTMLElement, statePromise: Promise<StateManager>) {
        this.statePromises.set(element, statePromise);
    }

    static async bind<T>(
        element: HTMLElement,
        path: string,
        handler: StateUpdateHandler<T>
    ): Promise<Unsubscribe> {
        const state = await this.statePromises.get(element);
        const callback = async (event: any) => {
            const value = await state.getValue(path);
            handler(value);
        };
        
        state.onStateUpdate(path, callback);
        const unsubscribe = () => state.offStateUpdate(path, callback);
        
        if (!this.subscriptions.has(element)) {
            this.subscriptions.set(element, []);
        }
        this.subscriptions.get(element)!.push(unsubscribe);
        
        // Initial update
        const initialValue = await state.getValue(path);
        handler(initialValue);
        
        return unsubscribe;
    }

    static disconnect(element: HTMLElement) {
        const subs = this.subscriptions.get(element) || [];
        subs.forEach(unsub => unsub());
        this.subscriptions.delete(element);
        this.statePromises.delete(element);
    }
}
```

### 2. State Provider Component (core/components/StateProvider.ts)
```typescript
import { OhaeLayoutView } from "./layout-view/OhaeLayoutView";
import { StateManager } from "../state/StateManager";
import { StateConnector } from "../state/StateConnector";

export class OhaeStateProvider extends OhaeLayoutView {
    private _stateManager: StateManager;

    constructor(stateManager: StateManager) {
        super();
        this._stateManager = stateManager;
    }

    protected override async createCallback() {
        await super.createCallback();
        this.propagateStateToChildren(this);
    }

    private propagateStateToChildren(element: Element) {
        element.querySelectorAll('*').forEach(child => {
            if (child instanceof HTMLElement) {
                StateConnector.connect(child, Promise.resolve(this._stateManager));
            }
        });
    }
}
```

### 3. Декораторы (core/decorators.ts)
```typescript
import { StateConnector } from "./state/StateConnector";

export function BindState(path: string) {
    return (target: any, propertyKey: string) => {
        const connectedCallback = target.connectedCallback;
        const disconnectedCallback = target.disconnectedCallback;

        target.connectedCallback = async function() {
            await connectedCallback?.call(this);
            const element = this as HTMLElement;
            
            StateConnector.bind(element, path, (value) => {
                this[propertyKey] = value;
            });
        };

        target.disconnectedCallback = function() {
            disconnectedCallback?.call(this);
            StateConnector.disconnect(this);
        };
    };
}

export function Action(statePath: string) {
    return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {
        const originalMethod = descriptor.value;
        
        descriptor.value = async function(...args: any[]) {
            const result = await originalMethod.apply(this, args);
            const state = await StateConnector['statePromises'].get(this);
            state.setValue(statePath, result);
            return result;
        };
        
        return descriptor;
    };
}
```

### 4. Модификация UI Components (пример для OhaeInputView)
```typescript
import { BindState, Action } from "../decorators";
import { OhaeBaseInputView } from "./OhaeBaseInputView";

export class OhaeInputView extends OhaeBaseInputView {
    @BindState('ui.inputs.textValue')
    declare value: string;

    @Action('ui.actions.lastInput')
    protected override modifyInputEvent(event: InputEvent) {
        const value = super.modifyInputEvent(event);
        return value;
    }

    // Автоматическая синхронизация при изменении состояния
    async attributeChangedCallback(name: string, oldVal: string, newVal: string) {
        super.attributeChangedCallback(name, oldVal, newVal);
        if (name === 'value') {
            const state = await StateConnector['statePromises'].get(this);
            state.setValue('ui.inputs.textValue', newVal);
        }
    }
}
```

### 5. State Persistence Service (core/state/StatePersist.ts)
```typescript
export class StatePersist {
    static async save(element: HTMLElement, path: string) {
        const state = await StateConnector['statePromises'].get(element);
        const attributes = Array.from(element.attributes)
            .reduce((acc, { name, value }) => {
                acc[name] = value;
                return acc;
            }, {} as Record<string, string>);
        
        state.setValue(`${path}.attributes`, attributes);
    }

    static async restore(element: HTMLElement, path: string) {
        const state = await StateConnector['statePromises'].get(element);
        const attributes = await state.getValue(`${path}.attributes`);
        
        Object.entries(attributes || {}).forEach(([name, value]) => {
            element.setAttribute(name, value);
        });
    }
}
```

### Примеры использования

#### 1. Подписка компонента на состояние
```typescript
import { OhaeButtonView } from "./OhaeButtonView";
import { BindState } from "./decorators";

export class ToolbarButton extends OhaeButtonView {
    @BindState('ui.toolbar.buttons.save')
    declare disabled: boolean;

    @BindState('ui.toolbar.buttons.save.icon')
    declare icon: string;
}
```

#### 2. Реактивное обновление сложного компонента
```typescript
export class CanvasView extends OhaeLayoutView {
    private async setup() {
        const state = await StateConnector['statePromises'].get(this);
        
        StateConnector.bind(this, 'canvas.layers', (layers) => {
            this.renderLayers(layers);
        });
        
        StateConnector.bind(this, 'canvas.activeTool', (tool) => {
            this.setActiveTool(tool);
        });
    }
    
    connectedCallback() {
        this.setup();
    }
}
```

#### 3. Сохранение/восстановление состояния
```typescript
// Сохранение текущего состояния
document.querySelector('ohae-editor').addEventListener('save', async (e) => {
    const editor = e.target as HTMLElement;
    await StatePersist.save(editor, 'editor.state');
});

// Восстановление при загрузке
window.addEventListener('load', async () => {
    const editor = document.querySelector('ohae-editor')!;
    await StatePersist.restore(editor, 'editor.state');
});
```

### Оптимизации для графического редактора

1. **Batch Updates**:
```typescript
class CanvasOptimizedView extends CanvasView {
    private updateQueue = new Set<string>();
    
    constructor() {
        super();
        this.debouncedUpdate = debounce(this.processUpdates, 100);
    }

    private async processUpdates() {
        const paths = Array.from(this.updateQueue);
        this.updateQueue.clear();
        
        const state = await StateConnector['statePromises'].get(this);
        const updates = await Promise.all(
            paths.map(path => state.getValue(path))
        );
        
        this.batchRender(updates);
    }

    @BindState('canvas.**') // Специальный синтаксис для групповых путей
    handleCanvasUpdate(path: string, value: any) {
        this.updateQueue.add(path);
        this.debouncedUpdate();
    }
}
```

2. **Priority Updates**:
```typescript
StateConnector.setPriorityRules({
    'canvas.viewport.**': 'high',
    'ui.sidebar.**': 'low',
    'default': 'normal'
});
```

Эта реализация обеспечивает:
- Автоматическую синхронизацию состояния и UI
- Поддержку сложных зависимостей между компонентами
- Оптимизированные обновления для тяжелых компонентов
- Простую интеграцию с существующей архитектурой
- Возможность отката изменений и сохранения состояний

Для дальнейшего развития можно добавить:
1. Визуальный дебаггер состояния
2. Систему плагинов для расширения функциональности
3. Оптимизированные селекторы для работы с большими данными
4. Поддержку распределенного состояния для плагинов
















<hr>

# Опиши, для чего нужны каждый из написанных тобой блоков с кодомРазберём назначение 

каждого компонента в предложенной архитектуре:

### 1. StateConnector (Ядро связывания)
```typescript
export class StateConnector extends Await {
    // ... implementation ...
}
```
**Назначение**: 
- Центральный координатор между состоянием и UI компонентами
- Управляет жизненным циклом подписок
- Автоматизирует синхронизацию данных
- Обеспечивает согласованность обновлений

**Ключевые функции**:
- `connect()` - Регистрирует компоненты в системе
- `bind()` - Создаёт двустороннюю связь свойство ↔ путь в состоянии
- `disconnect()` - Автоматическая очистка ресурсов

### 2. OhaeStateProvider (Контекстная обёртка)
```typescript
export class OhaeStateProvider extends OhaeLayoutView {
    // ... implementation ...
}
```
**Назначение**:
- Распространяет экземпляр StateManager по дереву компонентов
- Автоматически внедряет состояние в дочерние элементы
- Служит корневым контейнером для состояния приложения

**Особенности**:
- Паттерн Provider из React Context API
- Не требует явной передачи пропсов
- Гарантирует доступность состояния для всех потомков

### 3. Декораторы (Синтаксический сахар)
```typescript
export function BindState(path: string) { /*...*/ }
export function Action(statePath: string) { /*...*/ }
```
**Назначение**:
- Упрощают интеграцию состояния в компоненты
- Автоматизируют типовые операции:
  - `BindState` - синхронизация свойства с состоянием
  - `Action` - автоматическое сохранение результатов методов

**Преимущества**:
- Уменьшение шаблонного кода
- Читаемость конфигурации
- Централизованное управление связями

### 4. Модифицированный OhaeInputView (Пример интеграции)
```typescript
export class OhaeInputView extends OhaeBaseInputView {
    @BindState('ui.inputs.textValue')
    // ... implementation ...
}
```
**Назначение**:
- Демонстрация практического использования системы
- Автоматическая синхронизация поля ввода с состоянием
- Пример двустороннего связывания (UI ↔ State)

**Особенности**:
- Наследование от базового компонента
- Использование декораторов для декларативной конфигурации
- Обработка пользовательского ввода с автоматическим сохранением

### 5. StatePersist (Сериализация состояния)
```typescript
export class StatePersist {
    // ... implementation ...
}
```
**Назначение**:
- Сохранение/восстановление состояния компонентов
- Сериализация атрибутов UI в состояние
- Поддержка сценариев:
  - Автосохранение
  - Отмена/повтор действий
  - Восстановление сессии

**Использование**:
- Сохранение текущего состояния
- Миграция между версиями
- Экспорт/импорт проектов

### Примеры использования (Практические сценарии)

#### 1. Подписка компонента
```typescript
class ToolbarButton extends OhaeButtonView {
    @BindState('ui.toolbar.buttons.save')
    declare disabled: boolean;
}
```
**Механика**:
- Автоматическая подписка на изменения пути `ui.toolbar.buttons.save`
- Обновление свойства `disabled` при изменении состояния
- Автоматическая отписка при уничтожении компонента

#### 2. Реактивное обновление Canvas
```typescript
StateConnector.bind(this, 'canvas.layers', (layers) => {
    this.renderLayers(layers);
});
```
**Особенности**:
- Ручная подписка для сложных компонентов
- Оптимизированная перерисовка только изменённых слоёв
- Возможность кастомной обработки данных

#### 3. Сохранение состояния
```typescript
StatePersist.save(editor, 'editor.state');
```
**Процесс**:
1. Сбор всех атрибутов компонента
2. Сериализация в JSON
3. Сохранение в указанный путь состояния
4. Возможность восстановления в любой момент

### Оптимизации (Производительность)

#### Batch Updates
```typescript
this.debouncedUpdate = debounce(this.processUpdates, 100);
```
**Решает проблемы**:
- Множественные перерисовки при частых изменениях
- Избыточная нагрузка на рендер-движок
- "Дрожание" интерфейса

**Механика**:
- Накопление изменений в очереди
- Групповая обработка с заданным интервалом
- Интеллектуальное объединение изменений

#### Priority Updates
```typescript
StateConnector.setPriorityRules({
    'canvas.viewport.**': 'high',
    'ui.sidebar.**': 'low'
});
```
**Критерии**:
- `high`: Критичные обновления (например, холст)
- `normal`: Основной интерфейс
- `low`: Фоновые задачи

**Преимущества**:
- Гарантированная частота кадров для графики
- Приоритизация пользовательского ввода
- Оптимизация нагрузки на CPU

### Общая архитектура
```
[Пользователь]
    │
    ▼
[UI Компоненты] ◄───┐
    │               │
    ▼               │
[Декораторы] ────► [StateConnector] ◄───► [StateManager]
    │               │
    ▼               ▼
[Рендер]       [Сохранение/Восстановление]
```

**Поток данных**:
1. Пользователь взаимодействует с компонентом
2. Декоратор перехватывает действие
3. StateConnector обновляет состояние
4. Изменения распространяются на подписанные компоненты
5. Происходит реактивное обновление UI

**Преимущества для редактора**:
- Единый источник истины для всего приложения
- Предсказуемая работа с undo/redo
- Лёгкая интеграция новых инструментов
- Возможность удалённой коллаборации
- Профилирование и отладка изменений

Эта система обеспечивает баланс между производительностью и гибкостью, что критично для ресурсоёмких графических приложений.